// 1. Configuration
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 2. Enums
// Note: All enums previously used by the Profile model have been removed.
enum UserRole {
  CLIENT
  CONTRACTOR
  ADMIN
}

// 3. Models

model User {
  id                  String   @id @default(uuid())
  email               String   @unique
  password            String?
  firstName           String?
  lastName            String?
  fullName            String? 
  phoneNumber         String?  @unique
  role                UserRole @default(CLIENT)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  stripeCustomerId    String?
  isActive            Boolean  @default(true)
  isFrozen            Boolean  @default(false)
  googleId            String?
  emailVerified       Boolean  @default(false)
  verificationToken   String?

   vpcCredits            Int               @default(0) 

  // Relationships
  profile         Profile?
  loxoId          Int?      @unique  
  loxoJobs        LoxoJob[]  
  meetings        Meeting[]
  refreshTokens   RefreshToken[]
  hiredContracts  ClientContractor[] @relation("clientHires")
  contractsAsHired ClientContractor[] @relation("contractorHires")
  likedContractors LikedContractor[]  @relation("ClientLikes")
  likedByClients  LikedContractor[]  @relation("ContractorLikedBy")

  payments            Payment[] 

  @@index([googleId])
}

model LoxoJob {
  id                    String @id @default(uuid())
  loxoCandidateId       Int    @unique // Loxo's unique candidate ID
  jobId                 Int
  jobTitle              String
  jobPublishedName      String?
  
  userId                String
  user                  User   @relation(fields: [userId], references: [id])
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

model Profile {
  id                         String    @id @default(uuid())
  userId                     String    @unique
  user                       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  isVerified                 Boolean  @default(false)  


  // --- MODIFIED FIELDS ---
  roleType                   String[]
  verticalSpecialization     String[]
  rateRange                  String?
  englishProficiency         String?  
  availability               String?

  otherRoleType              String?
  otherVertical              String?
  yearsExperience            Int?
  skills                     String[]
  remoteTools                String[]
  spokenLanguages            String[]
  otherLanguage              String?
  customRate                 Float?
  resumeUrl                  String?
  profilePhotoUrl            String?
  internetSpeedScreenshotUrl String?
  timezone                   String?
  country                    String?
  otherCountry               String?
  videoIntroductionUrl       String?
  portfolioUrl               String?

  finalCost                   Float? // Using Float for currency values


  // Compliance fields...
  hipaaCertified             Boolean  @default(false)
  professionalCertValid      Boolean  @default(false)
  signedNda                  Boolean  @default(false)
  backgroundCheck            Boolean  @default(false)
  criminalRecordCheck        Boolean  @default(false)
  gdprTraining               Boolean  @default(false)
  pciCompliance              Boolean  @default(false)
  socialMediaScreening       Boolean  @default(false)
  usInsuranceCompliance      Boolean  @default(false)
  canadaInsuranceCompliance  Boolean  @default(false)
  willingToSignNda           Boolean  @default(false)
  willingBackgroundCheck     Boolean  @default(false)
  willingReferenceCheck      Boolean  @default(false)
  privacyPolicyConsent       Boolean  @default(false)
  creditCheck                Boolean  @default(false)
  vulnerableSectorCheck      Boolean  @default(false)
  contactConsent             Boolean  @default(false)
  emailConsent               Boolean  @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VpcPricing {
  id          String   @id @default(uuid())
  unitPrice   Int      // Storing in cents to avoid floating point issues, e.g., 7500 for $75.00
  currency    String   // e.g., 'usd'
  isActive    Boolean  @default(true) // To allow for future price changes without deleting old records
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}


model ClientContractor {
  id              String    @id @default(uuid())
  clientId        String
  contractorId    String
  hiredAt         DateTime  @default(now())
  active          Boolean   @default(true)
  endedAt         DateTime?
  paymentIntentId String?
  paymentAmount   Float?
  paymentStatus   String?   @default("pending")

  // Relationships
  client     User      @relation(name: "clientHires", fields: [clientId], references: [id], onDelete: Cascade)
  contractor User      @relation(name: "contractorHires", fields: [contractorId], references: [id], onDelete: Cascade)
  meetings   Meeting[]

  @@unique([clientId, contractorId])
  @@index([contractorId])
  @@index([clientId])
}

model LikedContractor {
  id           String   @id @default(uuid())
  clientId     String
  contractorId String
  createdAt    DateTime @default(now())

  // Relationships
  client     User @relation("ClientLikes", fields: [clientId], references: [id], onDelete: Cascade)
  contractor User @relation("ContractorLikedBy", fields: [contractorId], references: [id], onDelete: Cascade)

  @@unique([clientId, contractorId])
  @@index([clientId])
}

model Meeting {
  id                 String   @id @default(uuid())
  clientContractorId String
  clientContractor   ClientContractor @relation(fields: [clientContractorId], references: [id], onDelete: Cascade)
  title              String
  description        String?
  startTime          DateTime
  endTime            DateTime
  meetingUrl         String
  calendlyEventId    String?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  attendees          User[]
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}




// NEW: Payment Model for tracking all Stripe transactions
model Payment {
  id                  String    @id @default(uuid())
  userId              String    // The user who made the payment
  user                User      @relation(fields: [userId], references: [id])
  stripeSessionId     String?   @unique // The Stripe Checkout Session ID (for one-time payments)
  stripePaymentIntentId String? @unique // The Stripe Payment Intent ID (for direct charges or more detailed tracking)
  amount              Int       // Amount in cents (e.g., 1000 for $10.00)
  currency            String    // e.g., 'usd'
  status              String    // e.g., 'paid', 'pending', 'failed', 'refunded'
  description         String?   // Optional: A brief description of what was purchased
  // You can add a JSON field for storing full Stripe event data or metadata if needed
  // metadata            Json?     // Requires @prisma/client@2.23.0 or later and database support

  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@index([userId])
  @@index([stripeSessionId])
  @@index([stripePaymentIntentId])
}



model Employee {
  id                        Int             @id @default(autoincrement())  // ✅ Auto-generated PK
  loxoCandidateId           Int?
  workflow_stage_id         Int?
  position                    Int? 
  candidate_rejection_reason String?
  jobId                     Int?
  jobTitle                  String?
  jobPublishedName          String?

  // Relations
  personId                  Int             @unique
  person                    Person          @relation(fields: [personId], references: [id], onDelete: Cascade)

  latestPersonEventId       Int?            @unique
  latest_person_event       PersonEvent?    @relation(fields: [latestPersonEventId], references: [id], onDelete: SetNull)

  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt
}

model Person {
  id                         Int             @id @default(autoincrement())
  loxoId                     Int?     @unique 
  name                       String
  profile_picture_thumb_url  String?
  profile_picture_original_url String?
  location                   String?
  address                    String?
  city                       String?
  state                      String?
  zip                        String?
  country                    String?
  current_title              String?
  current_company            String?
  current_compensation       String?
  compensation               String?
  compensation_notes         String?
  compensation_currency_id   Int?
  salary                     String?
  salary_type_id             Int?

  owned_by_id                Int?
  created_by_id              Int?
  updated_by_id              Int?
  created_at                 DateTime?
  updated_at                 DateTime?
  linkedin_url               String?

  // Nested relations
  emails                     Email[]
  phones                     Phone[]
  person_types               PersonType[]

  employee                   Employee?       @relation
}

model Email {
  id             Int      @id @default(autoincrement()) // ✅ New auto-incrementing PK
  loxoId         Int?     @unique // Store the Loxo Email ID here
  value          String
  email_type_id  Int?
  person         Person  @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId       Int
}
model Phone {
  id            Int      @id @default(autoincrement()) // 🆕 New auto-incrementing primary key
  loxoId        Int?     @unique // 🆕 Store the Loxo ID here to avoid conflicts
  value         String
  phone_type_id Int?
  person        Person   @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId      Int
}

model PersonType {
  id            Int      @id @default(autoincrement()) // 🆕 New auto-incrementing primary key
  loxoId        Int?     @unique // 🆕 Store the Loxo ID here
  name          String
  person        Person   @relation(fields: [personId], references: [id], onDelete: Cascade)
  personId      Int
}

model PersonEvent {
  id                 Int      @id @default(autoincrement()) // 🆕 New auto-incrementing primary key
  loxoId             Int?     @unique // 🆕 Store the Loxo ID here
  activity_type_id   Int?
  created_at         DateTime?
  created_by_id      Int?
  updated_at         DateTime?
  updated_by_id      Int?
  employee           Employee?
}